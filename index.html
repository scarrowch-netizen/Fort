<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Mini Battle Royale (Embed)</title>
  <style>
    html, body { margin:0; padding:0; background:#0b1020; height:100%; overflow:hidden; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #wrap { position:fixed; inset:0; display:grid; place-items:center; }
    canvas { background: radial-gradient(1200px 800px at 50% 40%, #15224a 0%, #0b1020 55%, #070a14 100%); border-radius:16px; box-shadow:0 18px 60px rgba(0,0,0,.55); }
    #hud {
      position:fixed; left:12px; top:12px; color:#e8eeff; z-index:5;
      background:rgba(10,14,30,.55); backdrop-filter: blur(8px);
      border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:10px 12px; min-width:260px;
    }
    #hud b { font-weight:700; }
    #hud small { opacity:.8; }
    #bar { height:10px; background:rgba(255,255,255,.12); border-radius:999px; overflow:hidden; margin-top:6px; }
    #bar > div { height:100%; width:100%; background:linear-gradient(90deg, #53ff88, #2fd6ff); }
    #msg {
      position:fixed; right:12px; top:12px; color:#e8eeff; z-index:5;
      background:rgba(10,14,30,.55); backdrop-filter: blur(8px);
      border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:10px 12px; max-width:360px;
    }
    #center {
      position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; z-index:6;
      color:#e8eeff; text-align:center;
    }
    #center .card {
      pointer-events:auto;
      background:rgba(10,14,30,.65); border:1px solid rgba(255,255,255,.14);
      border-radius:18px; padding:18px 18px; max-width:520px; box-shadow:0 18px 60px rgba(0,0,0,.45);
    }
    #center button {
      cursor:pointer; border:0; border-radius:12px; padding:10px 14px;
      background:linear-gradient(90deg,#6a5cff,#2fd6ff);
      color:white; font-weight:700; margin-top:12px;
    }
    #center button:active { transform: translateY(1px); }
    a { color:#9bdcff; }
  </style>
</head>
<body>
  <div id="hud">
    <div><b>Mini BR</b> <small id="status">–</small></div>
    <div style="margin-top:6px; font-size:13px; line-height:1.35">
      <div>HP: <span id="hpTxt">100</span> · Kills: <span id="killsTxt">0</span> · Alive: <span id="aliveTxt">0</span></div>
      <div>Zone: <span id="zoneTxt">–</span></div>
      <div id="bar"><div id="hpBar"></div></div>
      <div style="margin-top:8px; opacity:.85">
        WASD/←↑↓→ bewegen · Maus zielen · Klick schießen · <b>Shift</b> sprinten · <b>R</b> restart
      </div>
    </div>
  </div>

  <div id="msg">
    <div style="font-weight:700; margin-bottom:6px;">Einbetten in Google Sites</div>
    <div style="font-size:13px; line-height:1.35; opacity:.9">
      Du musst diese HTML irgendwo hosten (HTTPS). Dann in Google Sites: <b>Einfügen → Einbetten → URL</b>
      und die URL zur HTML eintragen.
    </div>
  </div>

  <div id="center">
    <div class="card" id="startCard">
      <div style="font-size:20px; font-weight:800; margin-bottom:6px;">Mini Battle Royale</div>
      <div style="opacity:.9; line-height:1.4">
        Top-Down BR-inspiriert: Bots, Loot-HP, schrumpfende Zone, Schießen, Treffer.
        Läuft komplett im Browser (Canvas), ideal als iFrame-Embed.
      </div>
      <button id="startBtn">Start</button>
      <div style="margin-top:10px; font-size:12px; opacity:.75">
        Hinweis: Das ist <b>kein Fortnite</b>, sondern ein eigenes Mini-Spiel mit ähnlichen Grundideen.
      </div>
    </div>
  </div>

  <div id="wrap"><canvas id="c" width="960" height="540"></canvas></div>

<script>
(() => {
  "use strict";

  // ---------- Helpers ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const len = (x,y) => Math.hypot(x,y);
  const rnd = (a,b)=> a + Math.random()*(b-a);
  const now = ()=> performance.now()/1000;

  // ---------- Canvas & scaling ----------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height;

  function fit() {
    const pad = 16;
    const vw = window.innerWidth - pad*2;
    const vh = window.innerHeight - pad*2;
    const ar = W / H;
    let cw = vw, ch = vw / ar;
    if (ch > vh) { ch = vh; cw = vh * ar; }
    canvas.style.width = Math.max(320, cw) + "px";
    canvas.style.height = Math.max(180, ch) + "px";
  }
  window.addEventListener("resize", fit);
  fit();

  // ---------- Input ----------
  const keys = new Set();
  window.addEventListener("keydown", (e)=> {
    keys.add(e.key.toLowerCase());
    if (e.key.toLowerCase() === "r") reset();
  });
  window.addEventListener("keyup", (e)=> keys.delete(e.key.toLowerCase()));

  const pointer = { x: W/2, y: H/2, down:false };
  canvas.addEventListener("mousemove", (e)=> {
    const r = canvas.getBoundingClientRect();
    const sx = W / r.width, sy = H / r.height;
    pointer.x = (e.clientX - r.left) * sx;
    pointer.y = (e.clientY - r.top) * sy;
  });
  canvas.addEventListener("mousedown", ()=> pointer.down = true);
  window.addEventListener("mouseup", ()=> pointer.down = false);
  canvas.addEventListener("contextmenu", (e)=> e.preventDefault());

  // ---------- World ----------
  const world = {
    size: 2600,   // world is size x size
    obstacles: [],
    loot: [],
    bullets: [],
    particles: [],
    entities: [],
    running: false,
    t0: 0
  };

  function toScreen(wx, wy, cam) {
    return { x: wx - cam.x + W/2, y: wy - cam.y + H/2 };
  }
  function toWorld(sx, sy, cam) {
    return { x: sx + cam.x - W/2, y: sy + cam.y - H/2 };
  }

  function circleRectCollide(cx, cy, cr, rx, ry, rw, rh) {
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const d = len(cx-nx, cy-ny);
    return d < cr;
  }

  function makeObstacles() {
    world.obstacles = [];
    const n = 32;
    for (let i=0;i<n;i++) {
      const w = rnd(70, 220), h = rnd(70, 220);
      const x = rnd(200, world.size-200-w);
      const y = rnd(200, world.size-200-h);
      world.obstacles.push({x,y,w,h});
    }
  }

  function makeLoot() {
    world.loot = [];
    const n = 28;
    for (let i=0;i<n;i++) {
      const x = rnd(160, world.size-160);
      const y = rnd(160, world.size-160);
      world.loot.push({x,y,r:10, type:"hp", val: rnd(18, 35)});
    }
  }

  // ---------- Entities ----------
  function makePlayer() {
    return {
      kind:"player",
      x: world.size/2 + rnd(-120,120),
      y: world.size/2 + rnd(-120,120),
      r: 16,
      hp: 100,
      maxHp: 100,
      speed: 240,
      sprint: 1.55,
      fireRate: 8,       // bullets per sec
      lastShot: 0,
      kills: 0,
      alive: true,
      inv: 0
    };
  }

  function makeBot(id) {
    return {
      kind:"bot",
      id,
      x: rnd(200, world.size-200),
      y: rnd(200, world.size-200),
      r: 15,
      hp: 80,
      maxHp: 80,
      speed: rnd(175, 215),
      fireRate: rnd(3.5, 6.5),
      lastShot: 0,
      alive: true,
      target: null,
      roam: {x:rnd(300, world.size-300), y:rnd(300, world.size-300), t:0},
      strafe: rnd(-1,1)
    };
  }

  function spawnImpact(x,y, n=10) {
    for (let i=0;i<n;i++) {
      world.particles.push({
        x,y,
        vx:rnd(-1,1)*rnd(80,240),
        vy:rnd(-1,1)*rnd(80,240),
        life:rnd(0.18,0.38),
        t:0
      });
    }
  }

  function fireBullet(from, angle, speed, dmg) {
    world.bullets.push({
      x: from.x + Math.cos(angle)*from.r,
      y: from.y + Math.sin(angle)*from.r,
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed,
      r: 4.5,
      dmg,
      owner: from.kind,
      ttl: 1.2
    });
  }

  // ---------- Zone (shrinking circle) ----------
  const zone = {
    cx: 0, cy: 0,
    r0: 0,
    r: 0,
    rMin: 280,
    startDelay: 6.0,
    shrinkDuration: 120.0,
    dmgPerSec: 8.5
  };

  function resetZone() {
    zone.cx = world.size/2 + rnd(-180,180);
    zone.cy = world.size/2 + rnd(-180,180);
    zone.r0 = world.size*0.55;
    zone.r = zone.r0;
  }

  function zoneRadius(t) {
    const tt = Math.max(0, t - zone.startDelay);
    const k = clamp(tt / zone.shrinkDuration, 0, 1);
    return zone.r0 + (zone.rMin - zone.r0) * k;
  }

  // ---------- Game state ----------
  let player = null;
  let cam = {x:0,y:0};
  let last = now();
  let startedOnce = false;

  const ui = {
    status: document.getElementById("status"),
    hpTxt: document.getElementById("hpTxt"),
    killsTxt: document.getElementById("killsTxt"),
    aliveTxt: document.getElementById("aliveTxt"),
    zoneTxt: document.getElementById("zoneTxt"),
    hpBar: document.getElementById("hpBar"),
    startCard: document.getElementById("startCard"),
    startBtn: document.getElementById("startBtn")
  };

  ui.startBtn.addEventListener("click", () => {
    ui.startCard.style.display = "none";
    if (!startedOnce) { startedOnce = true; reset(); }
    world.running = true;
    world.t0 = now();
  });

  function reset() {
    world.bullets = [];
    world.particles = [];
    world.entities = [];
    makeObstacles();
    makeLoot();
    resetZone();

    player = makePlayer();
    world.entities.push(player);

    const botCount = 18;
    for (let i=0;i<botCount;i++) world.entities.push(makeBot(i+1));

    cam.x = player.x; cam.y = player.y;
    world.running = true;
    world.t0 = now();
  }

  function aliveCount() {
    return world.entities.filter(e => e.alive).length;
  }

  function applyMovement(ent, dx, dy, dt) {
    // Normalize
    const l = Math.hypot(dx,dy);
    if (l > 1e-6) { dx/=l; dy/=l; }
    ent.x += dx * ent.speed * dt;
    ent.y += dy * ent.speed * dt;

    // World bounds
    ent.x = clamp(ent.x, ent.r, world.size - ent.r);
    ent.y = clamp(ent.y, ent.r, world.size - ent.r);

    // Obstacles: simple push-out
    for (const o of world.obstacles) {
      if (circleRectCollide(ent.x, ent.y, ent.r, o.x, o.y, o.w, o.h)) {
        // push out by moving along smallest penetration axis
        const left = ent.x - o.x;
        const right = (o.x + o.w) - ent.x;
        const top = ent.y - o.y;
        const bottom = (o.y + o.h) - ent.y;
        const m = Math.min(left, right, top, bottom);
        if (m === left) ent.x = o.x - ent.r;
        else if (m === right) ent.x = o.x + o.w + ent.r;
        else if (m === top) ent.y = o.y - ent.r;
        else ent.y = o.y + o.h + ent.r;
      }
    }
  }

  function tryPickLoot(ent) {
    if (!ent.alive) return;
    for (let i=world.loot.length-1;i>=0;i--) {
      const L = world.loot[i];
      if (len(ent.x-L.x, ent.y-L.y) < ent.r + L.r + 6) {
        if (L.type === "hp") {
          ent.hp = Math.min(ent.maxHp, ent.hp + L.val);
          spawnImpact(L.x,L.y, 14);
          world.loot.splice(i,1);
        }
      }
    }
  }

  function damage(ent, amount, attackerKind) {
    if (!ent.alive) return;
    if (ent.kind === "player" && ent.inv > 0) return;
    ent.hp -= amount;
    if (ent.kind === "player") ent.inv = 0.12;
    if (ent.hp <= 0) {
      ent.hp = 0;
      ent.alive = false;
      spawnImpact(ent.x, ent.y, 28);

      // credit kill
      if (attackerKind === "player") player.kills += 1;
    }
  }

  function updatePlayer(dt, t) {
    if (!player.alive) return;

    const up = keys.has("w") || keys.has("arrowup");
    const dn = keys.has("s") || keys.has("arrowdown");
    const lt = keys.has("a") || keys.has("arrowleft");
    const rt = keys.has("d") || keys.has("arrowright");

    let dx = (rt?1:0) - (lt?1:0);
    let dy = (dn?1:0) - (up?1:0);

    const sprint = keys.has("shift") ? player.sprint : 1.0;
    const saved = player.speed;
    player.speed = saved * sprint;
    applyMovement(player, dx, dy, dt);
    player.speed = saved;

    tryPickLoot(player);

    // Aim
    const wpos = toWorld(pointer.x, pointer.y, cam);
    const ang = Math.atan2(wpos.y - player.y, wpos.x - player.x);

    // Shoot
    const wantShoot = pointer.down;
    const canShoot = (t - player.lastShot) >= (1 / player.fireRate);
    if (wantShoot && canShoot) {
      player.lastShot = t;
      fireBullet(player, ang, 820, 14);
    }

    if (player.inv > 0) player.inv -= dt;
  }

  function findNearestTarget(ent, maxDist=520) {
    let best = null, bd = Infinity;
    for (const e of world.entities) {
      if (!e.alive) continue;
      if (e === ent) continue;
      const d = len(e.x-ent.x, e.y-ent.y);
      if (d < bd && d < maxDist) { bd = d; best = e; }
    }
    return best;
  }

  function hasLineOfSight(ax, ay, bx, by) {
    // Very cheap LOS: sample a few points and check if inside any obstacle rect
    const steps = 10;
    for (let i=1;i<steps;i++) {
      const t = i/steps;
      const x = ax + (bx-ax)*t;
      const y = ay + (by-ay)*t;
      for (const o of world.obstacles) {
        if (x>o.x && x<o.x+o.w && y>o.y && y<o.y+o.h) return false;
      }
    }
    return true;
  }

  function updateBot(bot, dt, t) {
    if (!bot.alive) return;

    // Keep target if alive and close enough
    if (!bot.target || !bot.target.alive || len(bot.x-bot.target.x, bot.y-bot.target.y) > 700) {
      bot.target = findNearestTarget(bot, 700);
    }

    // Decide movement goal
    let gx = bot.roam.x, gy = bot.roam.y;
    let shoot = false;

    if (bot.target) {
      // Move a bit towards / strafe around target while staying in zone directionally
      const tx = bot.target.x, ty = bot.target.y;
      const d = len(tx-bot.x, ty-bot.y);
      const ang = Math.atan2(ty-bot.y, tx-bot.x);

      // strafe vector
      const sx = Math.cos(ang + Math.PI/2) * bot.strafe;
      const sy = Math.sin(ang + Math.PI/2) * bot.strafe;

      // prefer mid-range
      const desired = 260;
      const pull = clamp((d - desired)/desired, -1, 1);
      gx = bot.x + Math.cos(ang)*pull*240 + sx*140;
      gy = bot.y + Math.sin(ang)*pull*240 + sy*140;

      // shoot if LOS and within range
      if (d < 520 && hasLineOfSight(bot.x, bot.y, tx, ty)) shoot = true;

      // small randomness
      if (Math.random() < 0.004) bot.strafe = rnd(-1,1);
    } else {
      // roaming
      bot.roam.t += dt;
      if (bot.roam.t > 2.2 || len(bot.x-bot.roam.x, bot.y-bot.roam.y) < 40) {
        bot.roam = {x:rnd(260, world.size-260), y:rnd(260, world.size-260), t:0};
      }
    }

    // avoid being outside zone: bias goal toward zone center
    const zr = zone.r;
    const dz = len(bot.x-zone.cx, bot.y-zone.cy);
    if (dz > zr * 0.92) {
      const angz = Math.atan2(zone.cy-bot.y, zone.cx-bot.x);
      gx = bot.x + Math.cos(angz)*380;
      gy = bot.y + Math.sin(angz)*380;
    }

    // Move towards goal
    let dx = gx - bot.x, dy = gy - bot.y;
    applyMovement(bot, dx, dy, dt);

    tryPickLoot(bot);

    // Shoot
    if (shoot && bot.target) {
      const ang = Math.atan2(bot.target.y - bot.y, bot.target.x - bot.x);
      const canShoot = (t - bot.lastShot) >= (1 / bot.fireRate);
      if (canShoot) {
        bot.lastShot = t;
        fireBullet(bot, ang + rnd(-0.05,0.05), 760, 11);
      }
    }
  }

  function updateBullets(dt) {
    for (let i=world.bullets.length-1;i>=0;i--) {
      const b = world.bullets[i];
      b.ttl -= dt;
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      // out of world
      if (b.ttl <= 0 || b.x<0 || b.y<0 || b.x>world.size || b.y>world.size) {
        world.bullets.splice(i,1);
        continue;
      }

      // obstacle hit
      let hitObstacle = false;
      for (const o of world.obstacles) {
        if (b.x > o.x && b.x < o.x+o.w && b.y > o.y && b.y < o.y+o.h) {
          hitObstacle = true; break;
        }
      }
      if (hitObstacle) {
        spawnImpact(b.x,b.y, 10);
        world.bullets.splice(i,1);
        continue;
      }

      // entity hit
      for (const e of world.entities) {
        if (!e.alive) continue;
        if (b.owner === e.kind) continue; // friendly
        if (len(b.x-e.x, b.y-e.y) < b.r + e.r) {
          damage(e, b.dmg, b.owner);
          spawnImpact(b.x,b.y, 16);
          world.bullets.splice(i,1);
          break;
        }
      }
    }
  }

  function updateParticles(dt) {
    for (let i=world.particles.length-1;i>=0;i--) {
      const p = world.particles[i];
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= Math.pow(0.02, dt);
      p.vy *= Math.pow(0.02, dt);
      if (p.t > p.life) world.particles.splice(i,1);
    }
  }

  function updateZoneDamage(dt) {
    zone.r = zoneRadius(now() - world.t0);

    for (const e of world.entities) {
      if (!e.alive) continue;
      const d = len(e.x-zone.cx, e.y-zone.cy);
      if (d > zone.r) {
        damage(e, zone.dmgPerSec * dt, "zone");
      }
    }
  }

  function updateCam(dt) {
    // follow player
    const targetX = player.x;
    const targetY = player.y;
    cam.x += (targetX - cam.x) * (1 - Math.pow(0.0009, dt));
    cam.y += (targetY - cam.y) * (1 - Math.pow(0.0009, dt));
    cam.x = clamp(cam.x, W/2, world.size - W/2);
    cam.y = clamp(cam.y, H/2, world.size - H/2);
  }

  function checkWinLose() {
    const alive = world.entities.filter(e=>e.alive);
    if (player.alive && alive.length === 1) return "win";
    if (!player.alive) return "lose";
    return null;
  }

  // ---------- Rendering ----------
  function drawGrid() {
    const step = 80;
    const startX = Math.floor((cam.x - W/2) / step) * step;
    const startY = Math.floor((cam.y - H/2) / step) * step;
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#9bdcff";
    ctx.beginPath();
    for (let x = startX; x < cam.x + W/2 + step; x += step) {
      const s = toScreen(x, cam.y, cam);
      ctx.moveTo(s.x, 0); ctx.lineTo(s.x, H);
    }
    for (let y = startY; y < cam.y + H/2 + step; y += step) {
      const s = toScreen(cam.x, y, cam);
      ctx.moveTo(0, s.y); ctx.lineTo(W, s.y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawZone() {
    const c = toScreen(zone.cx, zone.cy, cam);
    ctx.save();

    // outside tint
    ctx.fillStyle = "rgba(155,220,255,0.06)";
    ctx.beginPath();
    ctx.rect(0,0,W,H);
    ctx.arc(c.x, c.y, zone.r, 0, Math.PI*2, true);
    ctx.fill("evenodd");

    // ring
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = "rgba(155,220,255,0.8)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(c.x, c.y, zone.r, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
  }

  function drawObstacles() {
    ctx.save();
    for (const o of world.obstacles) {
      const s = toScreen(o.x, o.y, cam);
      ctx.fillStyle = "rgba(255,255,255,0.10)";
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 2;
      roundRect(ctx, s.x, s.y, o.w, o.h, 12);
      ctx.fill();
      ctx.stroke();
    }
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawLoot() {
    ctx.save();
    for (const L of world.loot) {
      const s = toScreen(L.x, L.y, cam);
      ctx.fillStyle = "rgba(83,255,136,0.95)";
      ctx.beginPath();
      ctx.arc(s.x, s.y, L.r, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.22;
      ctx.beginPath();
      ctx.arc(s.x, s.y, L.r*2.4, 0, Math.PI*2);
      ctx.fillStyle = "rgba(83,255,136,1)";
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    ctx.restore();
  }

  function drawEntities() {
    for (const e of world.entities) {
      if (!e.alive) continue;
      const s = toScreen(e.x, e.y, cam);

      // body
      ctx.save();
      const isP = e.kind === "player";
      ctx.fillStyle = isP ? "rgba(106,92,255,0.95)" : "rgba(255,210,80,0.92)";
      ctx.beginPath();
      ctx.arc(s.x, s.y, e.r, 0, Math.PI*2);
      ctx.fill();

      // outline
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // hp arc
      const hpK = e.hp / e.maxHp;
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = "rgba(255,255,255,0.70)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(s.x, s.y, e.r+10, -Math.PI/2, -Math.PI/2 + Math.PI*2*hpK);
      ctx.stroke();

      // player inv flash
      if (isP && player.inv > 0) {
        ctx.globalAlpha = 0.35;
        ctx.beginPath();
        ctx.arc(s.x, s.y, e.r+6, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,1)";
        ctx.fill();
      }

      ctx.restore();
    }
  }

  function drawBullets() {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    for (const b of world.bullets) {
      const s = toScreen(b.x, b.y, cam);
      ctx.beginPath();
      ctx.arc(s.x, s.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawParticles() {
    ctx.save();
    for (const p of world.particles) {
      const k = 1 - (p.t / p.life);
      const s = toScreen(p.x, p.y, cam);
      ctx.globalAlpha = 0.6 * k;
      ctx.fillStyle = "rgba(155,220,255,1)";
      ctx.beginPath();
      ctx.arc(s.x, s.y, 2 + 4*(1-k), 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawAim() {
    if (!player.alive) return;
    const wpos = toWorld(pointer.x, pointer.y, cam);
    const ang = Math.atan2(wpos.y - player.y, wpos.x - player.x);
    const s = toScreen(player.x, player.y, cam);
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(s.x + Math.cos(ang)*46, s.y + Math.sin(ang)*46);
    ctx.stroke();

    // crosshair
    ctx.strokeStyle = "rgba(255,255,255,0.55)";
    ctx.beginPath();
    ctx.arc(pointer.x, pointer.y, 10, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  function render() {
    ctx.clearRect(0,0,W,H);

    drawGrid();
    drawZone();
    drawObstacles();
    drawLoot();
    drawBullets();
    drawParticles();
    drawEntities();
    drawAim();

    // vignette
    const g = ctx.createRadialGradient(W/2,H/2, Math.min(W,H)*0.18, W/2,H/2, Math.max(W,H)*0.7);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.45)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  // ---------- HUD ----------
  function updateHUD() {
    ui.hpTxt.textContent = Math.round(player.hp);
    ui.killsTxt.textContent = player.kills;
    ui.aliveTxt.textContent = aliveCount();
    ui.zoneTxt.textContent = `${Math.round(zone.r)} px`;
    ui.hpBar.style.width = `${clamp((player.hp/player.maxHp)*100, 0, 100)}%`;

    const alive = aliveCount();
    const res = checkWinLose();
    if (!world.running) ui.status.textContent = "paused";
    else if (res === "win") ui.status.textContent = "Victory Royale (Mini)!";
    else if (res === "lose") ui.status.textContent = "Eliminiert";
    else ui.status.textContent = "läuft";
  }

  function showEndOverlay(text) {
    const center = document.getElementById("center");
    center.innerHTML = `
      <div class="card">
        <div style="font-size:22px; font-weight:900; margin-bottom:8px;">${text}</div>
        <div style="opacity:.9; line-height:1.45">
          Kills: <b>${player.kills}</b> · Restart mit <b>R</b> oder Button.
        </div>
        <button id="again">Nochmal</button>
      </div>`;
    document.getElementById("again").addEventListener("click", () => {
      center.innerHTML = '';
      reset();
    });
  }

  // ---------- Main loop ----------
  function tick() {
    const t = now();
    const dt = clamp(t - last, 0, 0.033);
    last = t;

    if (world.running) {
      updatePlayer(dt, t);

      for (const e of world.entities) {
        if (e.kind === "bot") updateBot(e, dt, t);
      }

      updateBullets(dt);
      updateParticles(dt);
      updateZoneDamage(dt);
      updateCam(dt);

      const res = checkWinLose();
      if (res === "win") { world.running = false; showEndOverlay("Du hast gewonnen!"); }
      if (res === "lose") { world.running = false; showEndOverlay("Game Over"); }
    }

    updateHUD();
    render();
    requestAnimationFrame(tick);
  }

  // Start with intro screen visible
  ui.status.textContent = "bereit";
  updateHUD();
  requestAnimationFrame(tick);

})();
</script>
</body>
</html>
